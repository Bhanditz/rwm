\documentclass[article,nojss]{jss}
\usepackage{amsmath}
\def\command#1{{\it #1}}
\newfont{\tit}{cmss10 scaled\magstep1}
\def\ti#1{{\tit #1}}
\DeclareGraphicsExtensions{.pdf,.eps}

\author{A. I. McLeod\\University of Western Ontario }
\Plainauthor{A. I. McLeod}

\title{Vector thinking in \proglang{APL}, \proglang{R} and \proglang{Mathematica}}
\Plaintitle{Vector thinking in APL, R and Mathematica}

\Keywords{APL, Mathematica, R}
\Plainkeywords{APL, Mathematica, R}

\Abstract{
Functions for vectorizing computations in \proglang{APL}, \proglang{Mathematica}
and \proglang{R} are discussed.
Some exciting developments with \proglang{APL} are indicated.
}

\Address{
  A.I. McLeod\\
  University of Western Ontario\\
  E-mail: \email{aimcleod@uwo.ca}
}

\usepackage{Sweave}

\begin{document}

%\VignetteIndexEntry{Digression on APL}
%\VignetteKeywords{APL, Mathematica, R}
%\VignettePackage{rwm}


There are many similarities between \proglang{APL} and the \proglang{R}.
At the most fundamental conceptual level these languages emphasize the elegance
of vector thinking and the vectorization of computations \cite[Ch. 6.4]{JMChambers2008}.
For example, one method of generating 1000 NID(0, 1) random variables would be
to generate a matrix of dimension $12\times 1000$ of uniform $(0,1)$ random numbers
and then sum the columns and subtract 6.
In \proglang{R} we use \code{apply} but in \proglang{APL} the reduction operator \code{/}
plays the same role.
Similarly in \proglang{Mathematica}, in this situation, we would use
\code{Map} or \code{/@}.

Specifically in \proglang{R},
\begin{CodeChunk}
\begin{CodeInput}
R> X <- apply(matrix(runif(12*1000), nrow=1000), MARGIN=1, sum) - 6
\end{CodeInput}
\end{CodeChunk}

whereas in \proglang{APL},
%\hfil\break

{\it X} $\leftarrow \ ^-6$ ++/ ($10$$\star$$\ ^-6$) $\times$  $1000$ $12$ $\rho$ ? $10000$ $\rho 10$  $\star 6$

\smallskip
and in \proglang{Mathematica},
\begin{CodeChunk}
\begin{CodeInput}
X = Total /@ Partition[Array[Random[] &, 1000*12], 12] - 6;
\end{CodeInput}
\end{CodeChunk}

Vectorization of computations combined with an interactive programming environment,
pioneered in \proglang{APL}, has proved to be a very effective way of getting results fast.
In fact, \citet[p. 1408]{Wolfram03} lists nine similar
vector-thinking type functions in \proglang{APL}
and their equivalents in \proglang{Mathematica}.
Roughly speaking, for numerical computation, all nine of these vectorization functions have their {\tt builtin} 
approximate equivalents in \proglang{R} as well as shown in Table~2.

\vspace{0.1in}

\emph{Some basic vectorization functions in \proglang{APL}, \proglang{Mathematica} and \proglang{R}.
}

\begin{tabular}{lll}
\ti{APL}		& \ti{Mathematica}	& \ti{R}		\cr
{\tt catenate}     &  \code{Join}			&  \code{c}, \code{cbind}, \code{rbind}		      \cr
{\tt compress}     &  \code{Select}		    &  Index vectors$^*$  \cr
{\tt grade}        &  \code{Ordering}		&  \code{order}	  	\cr
{\tt grade} 		&  \code{Sort}			&  \code{sort}	 	\cr
{\tt iota operator}&  \code{Range}			&  \code{1:n}  		\cr
{\tt ravel} 		&  \code{Flatten}		&  \code{as.vector} 	\cr
{\tt reduce} 		&  \code{Map} 			&  \code{apply}	\cr
{\tt reshape} 		&  \code{Partition}		&  \code{dim}	  	\cr
{\tt shape} 		&  \code{Dimensions}	&  \code{dim} 		\cr
\end{tabular}

\noindent $\ ^*$ Index vectors, see \citet[Sections 2.7]{RIntro}

\vspace{0.1in}

Some of the previous books about \proglang{APL} include
\citep{SPakin1968, Polivka75, Anscombe81, NThomson81, Grenander82, Stiers83, HAPeell87, Helzer1989}.
The invited paper given by Iverson on receiving the Turning Award from ACM gives
many interesting examples of using \proglang{APL} as a tool of thought
\citep{KEIverson80}.

An overview of \proglang{APL} with links to many other current implementations
is available from \emph{Wikipedia},

\url{http://en.wikipedia.org/wiki/APL_%28programming_language%29}

Today there are many exciting developments in the use of \proglang{APL}
for software re-engineering \citep{Askoolum}.
A new \code{.Net} application of \proglang{APL} has been implemented
that is useful for internet applications utilizing Microsoft Office
products - see,

\url{http://www.aplnext.com/visualapl/getready/default.aspx}

Another very exciting development is the recent advent of 64-bit CPU
architecture. 
Such processors are capable of addressing $2^{32} = $ 4,294,967,296
locations in RAM memory and each address can contain 64-bit words.
This means for computer software that can take full advantage of these
new 64-bit CPUs we can potentially analyze quite large datasets
using \proglang{APL} or \proglang{R}.

There is a commerical release for a 64-bit version of R from REvolution Computing

\url{http://www.revolution-computing.com/}

And a 64-bit version of \proglang{APL} is available from MicroAPL:

\url{http://www.microapl.co.uk/APL/aplx64.html}

There are already 64-bit versions of \proglang{Mathematica} and \proglang{MatLab}.



\bibliography{rwmV}
\end{document}
